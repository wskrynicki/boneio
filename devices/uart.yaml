uart:
  id: mod_bus
  rx_pin: GPIO3
  tx_pin: GPIO1
  baud_rate: 9600
  stop_bits: 1
  debug:

modbus:
  uart_id: mod_bus
  id: modbus1
  send_wait_time: 500ms

modbus_controller:
- id: ch8_1st
  address: 2
  modbus_id: modbus1
  update_interval: 2s

switch:
- platform: uart
  name: "uart1"
  data: [0x02, 0x06, 0x00, 0x02, 0x03, 0x00, 0x28, 0xC9]

- platform: modbus_controller
  name: 'ch8_2st_1_holding'
  address: 0x0002
  register_type: holding
  bitmask: 1

#switch:
- platform: modbus_controller
  name: 'ch8_2st_2custom'
  custom_command: [0x02, 0x06, 0x00, 0x02, 0x03, 0x00]

#switch:
- platform: modbus_controller
  name: 'ch8_1st_1_lambda'
  address: 0x0002
  register_type: holding
#    bitmask: 1
  write_lambda: |-
    ESP_LOGD("main","Modbus Switch incoming state = %f",x);
    payload.push_back(0x2);  //device address
    payload.push_back(0x06);  //control command
    payload.push_back(0x00); //high byte address if coil
    payload.push_back(0x1);  //low byte address  of coil
    payload.push_back(0x03); //ON
    payload.push_back(0x0D);
    return true;
  
- platform: modbus_controller
  name: 'ch8_1st_1_lambda2'
  address: 0x0002
  register_type: holding
#    bitmask: 1
  write_lambda: |-
    payload.push_back(0x2);  //device address
    payload.push_back(0x06);  //control command
    payload.push_back(0x00); //high byte address if coil
    payload.push_back(0x1);  //low byte address  of coil
    payload.push_back(0x03); //ON
    payload.push_back(0x0D);
    return true;
